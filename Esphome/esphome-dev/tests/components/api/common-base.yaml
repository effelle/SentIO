esphome:
  on_boot:
    then:
      - wait_until:
          condition:
            api.connected:
              state_subscription_only: true
      - homeassistant.event:
          event: esphome.button_pressed
          data:
            message: Button was pressed
      - homeassistant.action:
          action: notify.html5
          data:
            message: Button was pressed
      - homeassistant.tag_scanned: pulse
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            entity_id: weather.forecast_home
            type: hourly
          capture_response: true
          on_success:
            - lambda: |-
                JsonObjectConst next_hour = response["response"]["weather.forecast_home"]["forecast"][0];
                float next_temperature = next_hour["temperature"].as<float>();
                ESP_LOGD("main", "Next hour temperature: %f", next_temperature);
          on_error:
            - lambda: |-
                ESP_LOGE("main", "Action failed with error: %s", error.c_str());
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            entity_id: weather.forecast_home
            type: hourly
          capture_response: true
          response_template: "{{ response['weather.forecast_home']['forecast'][0]['temperature'] }}"
          on_success:
            - lambda: |-
                float temperature = response["response"].as<float>();
                ESP_LOGD("main", "Next hour temperature: %f", temperature);
      - homeassistant.action:
          action: light.toggle
          data:
            entity_id: light.demo_light
          on_success:
            - logger.log: "Toggled demo light"
          on_error:
            - logger.log: "Failed to toggle demo light"

api:
  port: 8000
  reboot_timeout: 0min
  actions:
    - action: hello_world
      variables:
        name: string
      then:
        - logger.log:
            format: Hello World %s!
            args:
              - name.c_str()
    - action: empty_action
      then:
        - logger.log: Action Called
    - action: all_types
      variables:
        bool_: bool
        int_: int
        float_: float
        string_: string
      then:
        - logger.log: Something happened
    - action: array_types
      variables:
        bool_arr: bool[]
        int_arr: int[]
        float_arr: float[]
        string_arr: string[]
      then:
        - logger.log:
            # yamllint disable rule:line-length
            format: "Bool: %s (%u), Int: %ld (%u), Float: %f (%u), String: %s (%u)"
            # yamllint enable rule:line-length
            args:
              - YESNO(bool_arr[0])
              - bool_arr.size()
              - (long) int_arr[0]
              - int_arr.size()
              - float_arr[0]
              - float_arr.size()
              - string_arr[0].c_str()
              - string_arr.size()
    # Test ContinuationAction (IfAction with then/else branches)
    - action: test_if_action
      variables:
        condition: bool
        value: int
      then:
        - if:
            condition:
              lambda: 'return condition;'
            then:
              - logger.log:
                  format: "Condition true, value: %d"
                  args: ['value']
            else:
              - logger.log:
                  format: "Condition false, value: %d"
                  args: ['value']
        - logger.log: "After if/else"
    # Test nested IfAction (multiple ContinuationAction instances)
    - action: test_nested_if
      variables:
        outer: bool
        inner: bool
      then:
        - if:
            condition:
              lambda: 'return outer;'
            then:
              - if:
                  condition:
                    lambda: 'return inner;'
                  then:
                    - logger.log: "Both true"
                  else:
                    - logger.log: "Outer true, inner false"
            else:
              - logger.log: "Outer false"
        - logger.log: "After nested if"
    # Test WhileLoopContinuation (WhileAction)
    - action: test_while_action
      variables:
        max_count: int
      then:
        - lambda: 'id(api_continuation_test_counter) = 0;'
        - while:
            condition:
              lambda: 'return id(api_continuation_test_counter) < max_count;'
            then:
              - logger.log:
                  format: "While loop iteration: %d"
                  args: ['id(api_continuation_test_counter)']
              - lambda: 'id(api_continuation_test_counter)++;'
        - logger.log: "After while loop"
    # Test RepeatLoopContinuation (RepeatAction)
    - action: test_repeat_action
      variables:
        count: int
      then:
        - repeat:
            count: !lambda 'return count;'
            then:
              - logger.log:
                  format: "Repeat iteration: %d"
                  args: ['iteration']
        - logger.log: "After repeat"
    # Test combined continuations (if + while + repeat)
    - action: test_combined_continuations
      variables:
        do_loop: bool
        loop_count: int
      then:
        - if:
            condition:
              lambda: 'return do_loop;'
            then:
              - repeat:
                  count: !lambda 'return loop_count;'
                  then:
                    - lambda: 'id(api_continuation_test_counter) = iteration;'
                    - while:
                        condition:
                          lambda: 'return id(api_continuation_test_counter) > 0;'
                        then:
                          - logger.log:
                              format: "Combined: repeat=%d, while=%d"
                              args: ['iteration', 'id(api_continuation_test_counter)']
                          - lambda: 'id(api_continuation_test_counter)--;'
            else:
              - logger.log: "Skipped loops"
        - logger.log: "After combined test"
    # ==========================================================================
    # supports_response: status (auto-detected - api.respond without data)
    # Has call_id only - reports success/error without data payload
    # ==========================================================================
    - action: test_respond_status
      then:
        - api.respond:
            success: true
        - logger.log:
            format: "Status response sent (call_id=%d)"
            args: [call_id]

    - action: test_respond_status_error
      variables:
        error_msg: string
      then:
        - api.respond:
            success: false
            error_message: !lambda 'return error_msg;'

    # ==========================================================================
    # supports_response: optional (auto-detected - api.respond with data)
    # Has call_id and return_response - client decides if it wants response
    # ==========================================================================
    - action: test_respond_optional
      variables:
        sensor_name: string
        value: float
      then:
        - logger.log:
            format: "Optional response (call_id=%d, return_response=%d)"
            args: [call_id, return_response]
        - api.respond:
            data: !lambda |-
              root["sensor"] = sensor_name;
              root["value"] = value;
              root["unit"] = "Â°C";

    - action: test_respond_optional_conditional
      variables:
        do_succeed: bool
      then:
        - if:
            condition:
              lambda: 'return do_succeed;'
            then:
              - api.respond:
                  success: true
                  data: !lambda |-
                    root["status"] = "ok";
            else:
              - api.respond:
                  success: false
                  error_message: "Operation failed"

    # ==========================================================================
    # supports_response: only (explicit - always expects data response)
    # Has call_id only - response is always expected with data
    # ==========================================================================
    - action: test_respond_only
      supports_response: only
      variables:
        input: string
      then:
        - logger.log:
            format: "Only response (call_id=%d)"
            args: [call_id]
        - api.respond:
            data: !lambda |-
              root["input"] = input;
              root["processed"] = true;

    - action: test_respond_only_nested
      supports_response: only
      then:
        - api.respond:
            data: !lambda |-
              root["config"]["wifi"] = "connected";
              root["config"]["api"] = true;
              root["items"][0] = "item1";
              root["items"][1] = "item2";

    # ==========================================================================
    # supports_response: none (no api.respond action)
    # No call_id or return_response - just user variables
    # ==========================================================================
    - action: test_no_response
      variables:
        message: string
      then:
        - logger.log:
            format: "No response action: %s"
            args: [message.c_str()]

event:
  - platform: template
    name: Test Event
    id: test_event
    event_types:
      - single_click
      - double_click

globals:
  - id: api_continuation_test_counter
    type: int
    restore_value: false
    initial_value: '0'
